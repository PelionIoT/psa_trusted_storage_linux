/*
 * Copyright (c) 2019 Arm Limited and Contributors. All rights reserved.
 *
 * Based on: library/psa_its_file.c
 * In open-source project: https://github.com/ARMmbed/mbed-crypto
 *
 * Original file: Apache-2.0
 * Modifications: Copyright (c) 2019 Arm Limited and Contributors. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * This file is a modified version of mbed-crypto/library/psa_its_file.c v1.1.0d0.
 */
#include "config.h"

#if defined(_WIN32)
#include <windows.h>
#endif
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#include "psa/error.h"
#include "psa/storage_common.h"
#include "common_storage.h"
#include "mbedtls/ccm.h"
#include "mbedtls/entropy.h"

#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>


#define PSA_CS_PREFIX PSA_STORAGE_FILE_C_STORAGE_PREFIX

#define PSA_CS_FILENAME_PATTERN "%08lx%08lx"
#define PSA_CS_SUFFIX ".psa"

/* File objects created through the ITS API are stored in the
 * of PSA_CS_ITS_SUBPREFIX sub-directory of the
 * PSA_CS_PREFIX directory.
 * and include the "/" at the start. */
#define PSA_CS_ITS_SUBPREFIX "/its/"

/*Temporary define should be removed when sek will be generated by OPTEE TA*/
#define PSA_CS_SEK_ID 0x2900

#define PSA_CS_CCM_TAG_LENGTH_IN_BYTES 8 
#define PSA_CS_CCM_IV_LENGTH_IN_BYTES 12 
#define PSA_CS_SEK_LENGTH_IN_BYTES 16
#define PSA_CS_SEK_LENGTH_IN_BITS 128

/* File objects created through the PS API are stored in the
 * of PSA_CS_PS_SUBPREFIX sub-directory of the
 * PSA_CS_PREFIX directory.  Note this symbol
 * must be the same length as PSA_CS_ITS_SUBPREFIX which is
 * used to compute PSA_CS_FILENAME_LENGTH.*/
#define PSA_CS_PS_SUBPREFIX "/pst/"

#define PSA_CS_FILENAME_LENGTH         \
    ( sizeof( PSA_CS_PREFIX ) - 1 +     /*prefix without terminating 0*/ \
      sizeof( PSA_CS_ITS_SUBPREFIX ) - 1 + /*sub-prefix without terminating 0*/ \
      16 + /*UID (64-bit number in hex)*/                               \
      sizeof( PSA_CS_SUFFIX ) - 1 +     /*suffix without terminating 0*/ \
      1 /*terminating null byte*/ )
#define PSA_CS_TEMP \
    PSA_CS_PREFIX "tempfile" PSA_CS_SUFFIX

/* The maximum value of psa_storage_info_t.size */
#define PSA_CS_MAX_SIZE 0xffffffff

#define PSA_INTERNAL_TRUSTED_STORAGE_MAGIC_STRING "PSA\0ITS\0"
#define PSA_PROTECTED_STORAGE_MAGIC_STRING "PSA\0PST\0"
#define PSA_CS_MAGIC_LENGTH 8



/* As rename fails on Windows if the new filepath already exists,
 * use MoveFileExA with the MOVEFILE_REPLACE_EXISTING flag instead.
 * Returns 0 on success, nonzero on failure. */
#if defined(_WIN32)
#define rename_replace_existing( oldpath, newpath ) \
    ( ! MoveFileExA( oldpath, newpath, MOVEFILE_REPLACE_EXISTING ) )
#else
#define rename_replace_existing( oldpath, newpath ) rename( oldpath, newpath )
#endif


static psa_status_t psa_cs_decrypt_buffer(unsigned char *enc_buffer,
                                         size_t encr_buffer_length,
                                         psa_storage_uid_t uid,
                                         const unsigned char *sek_buffer,
                                         size_t sek_buffer_length,
                                         unsigned char *decr_buffer,
                                         size_t *decr_buffer_length);


typedef struct
{
    uint8_t magic[PSA_CS_MAGIC_LENGTH];
    uint8_t size[sizeof( uint32_t )];
    uint8_t flags[sizeof( psa_storage_create_flags_t )];
} psa_its_file_header_t;

static psa_status_t psa_its_fill_filename( psa_storage_uid_t uid, char *filename, psa_cs_api_t api )
{
    char *subprefix = PSA_CS_ITS_SUBPREFIX;

    /* check api parameter */
    if ( api >= PSA_CS_API_MAX )
        return( PSA_ERROR_GENERIC_ERROR );

    /* Break up the UID into two 32-bit pieces so as not to rely on
     * long long support in snprintf. */
    subprefix = api == PSA_CS_API_PS ? PSA_CS_PS_SUBPREFIX : subprefix;
    snprintf( filename, PSA_CS_FILENAME_LENGTH,
                      "%s%s" PSA_CS_FILENAME_PATTERN "%s",
                      PSA_CS_PREFIX,
                      subprefix,
                      (unsigned long) ( uid >> 32 ),
                      (unsigned long) ( uid & 0xffffffff ),
                      PSA_CS_SUFFIX );

    return( PSA_SUCCESS );
}

static psa_status_t psa_its_read_file( psa_storage_uid_t uid,
                                       const unsigned char *sek_buffer,
                                       size_t sek_buffer_length,
                                       struct psa_storage_info_t *p_info,                                  
                                       psa_cs_api_t api,
                                       unsigned char **file_data,
                                       size_t *file_data_length)
{
    char filename[PSA_CS_FILENAME_LENGTH];
    char *magic_string = PSA_INTERNAL_TRUSTED_STORAGE_MAGIC_STRING;
    psa_its_file_header_t header;
    size_t n;
    psa_status_t status;
    size_t size_of_file = 0;
    size_t actual_decryted_size = 0;
    FILE *p_stream = NULL;
    *file_data = NULL;

    //Compose file name
    status = psa_its_fill_filename( uid, filename, api );
    if( status != PSA_SUCCESS )
        return( status );

    p_stream = fopen( filename, "rb" );
    if( p_stream == NULL )
        return( PSA_ERROR_DOES_NOT_EXIST );

    //Get the size of the ecrypted file
    if( fseek( p_stream, 0L, SEEK_END ) != 0 ){
        status  = PSA_ERROR_INVALID_ARGUMENT;
        goto exit;  
    }
    size_of_file = ftell(p_stream);

    //Allocate memory for the ecrypted file
    *file_data = malloc(size_of_file);
    if (*file_data == NULL){
        status  = PSA_ERROR_GENERIC_ERROR;
        goto exit;          
    }

    //Set the stream back to the start of the file
    if( fseek(p_stream, 0L, SEEK_SET) != 0 ){
        status  = PSA_ERROR_INVALID_ARGUMENT;
        goto exit;  
    }   

    //Read the encrypted file
    n = fread( *file_data, 1, size_of_file, p_stream);
    if( n != size_of_file ){
        status  = PSA_ERROR_DATA_CORRUPT;
        goto exit;  
    }

    //Decrypt file data (inplace)
    status =  psa_cs_decrypt_buffer((unsigned char*)*file_data, //in encrypted buffer
                                    size_of_file,
                                    uid, sek_buffer,
                                    sek_buffer_length,
                                    (unsigned char*)*file_data, //out decrypted file
                                    &actual_decryted_size);

    //Check that decrypted file size has at least size of the header                 
    if( actual_decryted_size < sizeof(header) ){
        status  = PSA_ERROR_DATA_CORRUPT;
        goto exit;  
    }

    //Check the header
    memcpy(&header, *file_data, sizeof( header));
    magic_string = api == PSA_CS_API_PS ? PSA_PROTECTED_STORAGE_MAGIC_STRING : magic_string;
    if( memcmp( header.magic, magic_string, PSA_CS_MAGIC_LENGTH ) != 0 ){
        status  = PSA_ERROR_DATA_CORRUPT;
        goto exit;
    }
    //Set size and flags info
    p_info->size = ( header.size[0] |
                     header.size[1] << 8 |
                     header.size[2] << 16 |
                     header.size[3] << 24 );
    p_info->flags = ( header.flags[0] |
                      header.flags[1] << 8 |
                      header.flags[2] << 16 |
                      header.flags[3] << 24 );

    //Check the size of the decrypted data according to the header info
    if(p_info->size != actual_decryted_size - sizeof(header)){
        status  = PSA_ERROR_DATA_CORRUPT;
        goto exit;       
    }

    //Update the output file data length TODO: check the size that should be returened!!!
    *file_data_length = actual_decryted_size - PSA_CS_CCM_TAG_LENGTH_IN_BYTES - PSA_CS_CCM_IV_LENGTH_IN_BYTES;
    status = PSA_SUCCESS;
exit:
    if( status != PSA_SUCCESS){
        if (*file_data){
            free(*file_data);
            *file_data = NULL;
        }
    }

    if (p_stream){
        fclose( p_stream );
    }
    return status;
}
static psa_status_t psa_cs_generate_random_buffer(unsigned char* buffer, size_t buffer_length){

    int ret = 0;
#if !defined(MBEDTLS_SSL_CONF_RNG)
    mbedtls_entropy_context entropy_ctx;

    mbedtls_entropy_init(&entropy_ctx);
    ret = mbedtls_entropy_func(&entropy_ctx, buffer, buffer_length);
    mbedtls_entropy_free(&entropy_ctx);
#else
    ret = global_rng(NULL, buffer, buffer_length);
#endif // !defined(MBEDTLS_SSL_CONF_RNG)

    if (ret) {
        //Failed to generate SEK
        return  PSA_ERROR_GENERIC_ERROR;
    }  
    return  PSA_SUCCESS;
}

static psa_status_t psa_cs_set_sek(unsigned char *sek_buffer, size_t sek_buffer_length, const char *sek_filename){
    psa_status_t status = PSA_ERROR_STORAGE_FAILURE;
    FILE *stream = NULL;
    size_t n;

    //Generate random SEK
    status = psa_cs_generate_random_buffer(sek_buffer, sek_buffer_length);

    if (status != PSA_SUCCESS) {
        //Failed to generate SEK
        return PSA_ERROR_GENERIC_ERROR;
    } else {
        //SEK was generated - write the data to the file
        stream = fopen( sek_filename, "wb" );
        if( stream == NULL )
        {
            status = PSA_ERROR_GENERIC_ERROR;
            goto exit;
        }

        //Write SEK data to the file
        n = fwrite( sek_buffer, 1, sek_buffer_length, stream );
        if( n != sek_buffer_length){
            status = PSA_ERROR_STORAGE_FAILURE;
            goto exit;
        }
        status = PSA_SUCCESS;
    }

exit:
    if( stream != NULL )
    {
        fclose( stream );
    }
    return status;
}

static psa_status_t psa_cs_get_sub_prefix_dir(char *filename, size_t filename_size, psa_cs_api_t api){

    char *subprefix = PSA_CS_ITS_SUBPREFIX;
    struct stat st = { 0 };
    int res = 0;

    /* Check if sub-prefix directory for storing files has been created and if not
     * create it. */
    subprefix = api == PSA_CS_API_PS ? PSA_CS_PS_SUBPREFIX : subprefix;
    snprintf( filename, filename_size, "%s%s", PSA_CS_PREFIX, subprefix );
    if ( stat( filename, &st ) == -1 )
    {
        res = mkdir( filename, 0700 );
        if ( res != 0 )
            return( PSA_ERROR_GENERIC_ERROR );
    }

    return PSA_SUCCESS;
}

static psa_status_t psa_cs_read_sek(unsigned char *sek_buffer, size_t sek_buffer_length, psa_cs_api_t api)
{
    psa_status_t status = PSA_ERROR_STORAGE_FAILURE;
    char sek_filename[PSA_CS_FILENAME_LENGTH];
    char sub_prefix_dir[PSA_CS_FILENAME_LENGTH];
    FILE *stream = NULL;
    size_t n;

    //Get sub prefix directory
    status =  psa_cs_get_sub_prefix_dir(sub_prefix_dir, PSA_CS_FILENAME_LENGTH, api);
    if( status != PSA_SUCCESS ){
        return status;
    }

    /*Current logic is temporary and will be replaced by HOST OPTEE logic once OPTEE TA is ready for integration*/
    /* 1. Create full file name of SEK.
       2. Read the file and return the data.
       3. If SEK doesn't exists - generate a new SEK save it to the sek file and return the data*/
    //Build sub_dir_name
    memcpy(sek_filename, sub_prefix_dir, PSA_CS_FILENAME_LENGTH);

    /* Buld the full file name of the SEK*/
    status = psa_its_fill_filename((psa_storage_uid_t)PSA_CS_SEK_ID, sek_filename, api);
    if( status != PSA_SUCCESS ){
        return status;
    }  

    //Read SEK file
    stream = fopen( sek_filename, "rb" );
    if( stream == NULL ){
        //The file doesn't exist - generate and set a new SEK
        status = psa_cs_set_sek(sek_buffer, sek_buffer_length, sek_filename);
    } else {
        //Read SEK data from the file
        n = fread( sek_buffer, 1, sek_buffer_length, stream);
        if( n != sek_buffer_length ) {
           status = PSA_ERROR_DATA_CORRUPT;
        }
    }

    if( stream != NULL ){
        fclose( stream );
    }
    return( status );
}


/*
  Data file structure:

  1. File header
  2. Actual file data.
  3. IV data that was used for encryption.
  4. CCM tag data that was used for encryption.

  * 1 and 2 encrypted as one buffer using SEK(currently saved as non-encrypted file), IV and uid as additional data.
  * 3 and 4 saved as plain data - should be used for decryption with uid as additional data.
*/
static psa_status_t psa_cs_decrypt_buffer(unsigned char *enc_buffer,
                                         size_t encr_buffer_length,
                                         psa_storage_uid_t uid,
                                         const unsigned char *sek_buffer,
                                         size_t sek_buffer_length,
                                         unsigned char *decr_buffer,
                                         size_t *decr_buffer_length)
 {
    psa_status_t status = PSA_ERROR_STORAGE_FAILURE;
    int res = 0;
    mbedtls_ccm_context ctx;
    unsigned char iv_buffer[PSA_CS_CCM_IV_LENGTH_IN_BYTES] = {0x0};
    unsigned char ccm_tag[PSA_CS_CCM_TAG_LENGTH_IN_BYTES] = {0};

    //Get ccm tag data from the buffer, the tag data is not encrypted
    memcpy(ccm_tag, enc_buffer + encr_buffer_length - PSA_CS_CCM_TAG_LENGTH_IN_BYTES, PSA_CS_CCM_TAG_LENGTH_IN_BYTES);
 
    //Get ccm iv data from the buffer, the iv data is not encrypted
    memcpy(iv_buffer, enc_buffer + encr_buffer_length - PSA_CS_CCM_TAG_LENGTH_IN_BYTES - PSA_CS_CCM_IV_LENGTH_IN_BYTES, PSA_CS_CCM_IV_LENGTH_IN_BYTES);

    //Initialize ccm context
    mbedtls_ccm_init(&ctx);

    //Set encryption key
    res =  mbedtls_ccm_setkey(&ctx,
                              MBEDTLS_CIPHER_ID_AES,
                              sek_buffer,
                              sek_buffer_length*8); //convert to bits size
    if (res){
        status = PSA_ERROR_GENERIC_ERROR;
        goto exit;
    }
    
    //Decrypt data
    res = mbedtls_ccm_auth_decrypt(&ctx,
                                   encr_buffer_length - PSA_CS_CCM_TAG_LENGTH_IN_BYTES - PSA_CS_CCM_IV_LENGTH_IN_BYTES,
                                   iv_buffer,
                                   PSA_CS_CCM_IV_LENGTH_IN_BYTES,
                                   (const unsigned char*)&uid, 
                                   sizeof(psa_storage_uid_t), 
                                   enc_buffer,
                                   decr_buffer,
                                   ccm_tag,
                                   PSA_CS_CCM_TAG_LENGTH_IN_BYTES);
    if (res){
        status = PSA_ERROR_GENERIC_ERROR;
        goto exit;
    }

    //Update size of the decrypted buffer
    *decr_buffer_length = encr_buffer_length - PSA_CS_CCM_IV_LENGTH_IN_BYTES - PSA_CS_CCM_TAG_LENGTH_IN_BYTES;
    status = PSA_SUCCESS;
exit:
    //Finalize ccm context
    mbedtls_ccm_free(&ctx);
    return( status );
 }  
/*
  Data file structure:

  1. File header
  2. Actual file data.
  3. IV data that was used for encryption.
  4. CCM tag data that was used for encryption.

  * 1 and 2 encrypted as one buffer using SEK(currently saved as non-encrypted file), IV and uid as additional data.
  * 3 and 4 saved as plain data - should be used for decryption with uid as additional data.
*/
static psa_status_t psa_cs_encrypt_buffer(const unsigned char *header, 
                                          size_t header_length,
                                          const void *p_data,
                                          size_t data_length,
                                          psa_storage_uid_t uid,
                                          const unsigned char *sek_buffer,
                                          size_t sek_buffer_length,
                                          unsigned char **encrypted_buffer,
                                          size_t  *encrypted_buffer_length){
   psa_status_t status = PSA_ERROR_STORAGE_FAILURE;
    int res = 0;
    mbedtls_ccm_context ctx;
    unsigned char *enc_buffer = NULL;
    unsigned char iv_buffer[PSA_CS_CCM_IV_LENGTH_IN_BYTES] = {0x0};
    unsigned char ccm_tag[PSA_CS_CCM_TAG_LENGTH_IN_BYTES] = {0};
    //The encrypted buffer size
    size_t size_to_allocate = header_length + data_length + PSA_CS_CCM_TAG_LENGTH_IN_BYTES + PSA_CS_CCM_IV_LENGTH_IN_BYTES;

    //Allocate buffer for encrypted data
    enc_buffer = (unsigned char *)malloc(size_to_allocate);
    if (enc_buffer == NULL){
        return PSA_ERROR_GENERIC_ERROR;
    }


    //Copy header and data to allocated encrypted buffer
    memcpy(enc_buffer, header, header_length);
    memcpy(enc_buffer+header_length, p_data, data_length);

   //Generate IV
    status = psa_cs_generate_random_buffer(iv_buffer, PSA_CS_CCM_IV_LENGTH_IN_BYTES);
    if (status != PSA_SUCCESS){
        goto exit;
    }

    //Initialize ccm context
    mbedtls_ccm_init(&ctx);

    //Set encryption key
    res =  mbedtls_ccm_setkey(&ctx,
                              MBEDTLS_CIPHER_ID_AES,
                              sek_buffer,
                              sek_buffer_length*8); //convert to bits size
    if (res){
        status = PSA_ERROR_GENERIC_ERROR;
        goto exit;
    }

    //Encrypt data
    res = mbedtls_ccm_encrypt_and_tag(&ctx,
                                     header_length + data_length,
                                     iv_buffer,
                                     PSA_CS_CCM_IV_LENGTH_IN_BYTES, 
                                     (const unsigned char*)&uid, 
                                     sizeof(psa_storage_uid_t),
                                     enc_buffer,
                                     enc_buffer,
                                     ccm_tag,
                                     PSA_CS_CCM_TAG_LENGTH_IN_BYTES);
    if (res){
        status = PSA_ERROR_GENERIC_ERROR;
        goto exit;
    }

    //Add generated IV and tag at the end of the encrypted data buffer as plain data
    memcpy(enc_buffer + header_length + data_length, iv_buffer, PSA_CS_CCM_IV_LENGTH_IN_BYTES);
    memcpy(enc_buffer + header_length + data_length + PSA_CS_CCM_IV_LENGTH_IN_BYTES , ccm_tag, PSA_CS_CCM_TAG_LENGTH_IN_BYTES);
    
    //Set output to encrypted buffer pointer
    *encrypted_buffer = enc_buffer;
    //Update encrypted buffer size to the full size including IV and tag, as this data will be written to the storage
    *encrypted_buffer_length = size_to_allocate;
    status = PSA_SUCCESS;

exit:
    mbedtls_ccm_free(&ctx);
    if (status != PSA_SUCCESS){
        if(enc_buffer != NULL){
            free(enc_buffer);
        } 
    }
    return( status );
}

/***************************************************************************************************************/
psa_status_t psa_cs_get_info( psa_storage_uid_t uid,
                              struct psa_storage_info_t *p_info,
                              psa_cs_api_t api )
{
    psa_status_t status;
    unsigned char *file_data = NULL;
    size_t file_data_length = 0;
    unsigned char sek_buffer[PSA_CS_SEK_LENGTH_IN_BYTES];

    /* Read storage encryption key (SEK). If the key doesn't exist generate a new SEK. */
    status = psa_cs_read_sek(sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, api);
    if( status != PSA_SUCCESS ){
        return status;
    }
    
    //Read the file using SEK
    status = psa_its_read_file( uid, sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, p_info, api, &file_data, &file_data_length);
    if( file_data != NULL )
        free( file_data );
    memset(sek_buffer, 0 , PSA_CS_SEK_LENGTH_IN_BYTES);
    return( status );
}

psa_status_t psa_cs_get( psa_storage_uid_t uid,
                         size_t data_offset,
                         size_t data_size,
                         void *p_data,
                         size_t *p_data_length,
                         psa_cs_api_t api )
{
    psa_status_t status;
    unsigned char *file_data = NULL;
    size_t file_data_length = 0;
    unsigned char sek_buffer[PSA_CS_SEK_LENGTH_IN_BYTES];
    struct psa_storage_info_t info;
    unsigned char *data_start = NULL;

    /* Read storage encryption key (SEK). If the key doesn't exist generate a new SEK. */
    status = psa_cs_read_sek(sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, api);
    if( status != PSA_SUCCESS ){
        return status;
    }

    //Read the file using SEK
    status = psa_its_read_file( uid, sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, &info, api, &file_data, &file_data_length);
    if( status != PSA_SUCCESS )
        goto exit;
  
    status = PSA_ERROR_INVALID_ARGUMENT;

    //Check data parameters
    if( data_offset + data_size < data_offset )
        goto exit;
#if SIZE_MAX < 0xffffffff
    if( data_offset + data_size > SIZE_MAX )
        goto exit;
#endif
    if( data_offset + data_size > info.size )
        goto exit;

    status = PSA_ERROR_STORAGE_FAILURE;

    //set data_start to point after the header
    data_start = file_data + sizeof(psa_its_file_header_t);

#if LONG_MAX < 0xffffffff
    //Iterate until data_offset < LONG_MAX
    while( data_offset > LONG_MAX )
    {
        data_start = data_start + LONG_MAX;
        data_offset -= LONG_MAX;
    }
#endif
    //Set data_start pointer to the data_offset
    data_start = data_start + data_offset;

    //Copy the data to output buffer
    memcpy(p_data, data_start, data_size);

    if( p_data_length )
        *p_data_length = data_size;

    status = PSA_SUCCESS;
exit:
    memset(sek_buffer, 0 , PSA_CS_SEK_LENGTH_IN_BYTES);
    if( file_data != NULL )
        free(file_data);
    return( status );
}

psa_status_t psa_cs_set( psa_storage_uid_t uid,
                          size_t data_length,
                          const void *p_data,
                          psa_storage_create_flags_t create_flags,
                          psa_cs_api_t api )
{
    psa_status_t status = PSA_ERROR_STORAGE_FAILURE;
    char filename[PSA_CS_FILENAME_LENGTH];
    unsigned char sek_buffer[PSA_CS_SEK_LENGTH_IN_BYTES];
    char *magic_string = PSA_INTERNAL_TRUSTED_STORAGE_MAGIC_STRING;
    FILE *stream = NULL;
    psa_its_file_header_t header;
    size_t n;
    struct psa_storage_info_t info;
    unsigned char *encrypted_buffer = NULL;
    size_t encrypted_buffer_length = 0;
    //unsigned char *full_data_buffer = NULL;
    //size_t full_data_length = 0;
    unsigned char *read_file_data = NULL;
    size_t read_file_data_length = 0;

    /* As all files are stored on encrypted file system, a request for no confidentiality
     * is upgraded to confidentiality. Hence if set the PSA_STORAGE_FLAG_NO_CONFIDENTIALITY
     * bit is cleared. */
    if( create_flags & PSA_STORAGE_FLAG_NO_CONFIDENTIALITY )
        create_flags &= ~PSA_STORAGE_FLAG_NO_CONFIDENTIALITY;

    //Get sub prefix directory
    status =  psa_cs_get_sub_prefix_dir(filename, PSA_CS_FILENAME_LENGTH, api);
    if( status != PSA_SUCCESS ){
        return status;
    }

    /*Read storage encryption key (SEK)nat*/
    status = psa_cs_read_sek(sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, api);
    if( status != PSA_SUCCESS ){
        return status;
    }

    /* If the file object already exists and PSA_STORAGE_FLAG_WRITE_ONCE is set then do
     * not update the object. */
    status = psa_its_read_file(uid, sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, &info, api, &read_file_data, &read_file_data_length);
    if( status == PSA_SUCCESS )
    {
        if(read_file_data){
            free(read_file_data);
        }
        if( info.flags & PSA_STORAGE_FLAG_WRITE_ONCE )
            return ( PSA_ERROR_NOT_PERMITTED );
    }

    magic_string = api == PSA_CS_API_PS ? PSA_PROTECTED_STORAGE_MAGIC_STRING : magic_string;
    memcpy( header.magic, magic_string, PSA_CS_MAGIC_LENGTH );
    header.size[0] = data_length & 0xff;
    header.size[1] = ( data_length >> 8 ) & 0xff;
    header.size[2] = ( data_length >> 16 ) & 0xff;
    header.size[3] = ( data_length >> 24 ) & 0xff;
    header.flags[0] = create_flags & 0xff;
    header.flags[1] = ( create_flags >> 8 ) & 0xff;
    header.flags[2] = ( create_flags >> 16 ) & 0xff;
    header.flags[3] = ( create_flags >> 24 ) & 0xff;

    status = psa_its_fill_filename( uid, filename, api );
    if( status != PSA_SUCCESS )
        goto exit;
    stream = fopen( PSA_CS_TEMP, "wb" );
    if( stream == NULL )
    {
        status = PSA_ERROR_GENERIC_ERROR;
        goto exit;
    }

    status = PSA_ERROR_INSUFFICIENT_STORAGE;

    /*Encrypt data*/
    status = psa_cs_encrypt_buffer((const unsigned char*)&header, sizeof(psa_its_file_header_t),
                                   (const unsigned char*) p_data, data_length,
                                    uid, 
                                    sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, 
                                    &encrypted_buffer, &encrypted_buffer_length);
    if (status != PSA_SUCCESS){
        goto exit;
    }

    //Write encrypted buffer (encrypted buffer : encrypted header and data + plain IV + plain tag)
    n = fwrite( encrypted_buffer, 1, encrypted_buffer_length, stream );
    if( n != encrypted_buffer_length)
        goto exit;
    status = PSA_SUCCESS;

exit:
    memset(sek_buffer, 0 , PSA_CS_SEK_LENGTH_IN_BYTES);
    if( stream != NULL )
    {
        int ret = fclose( stream );
        if( status == PSA_SUCCESS && ret != 0 )
            status = PSA_ERROR_INSUFFICIENT_STORAGE;
    }
    if ( encrypted_buffer != NULL){
        free(encrypted_buffer);
    }

    if( status == PSA_SUCCESS )
    {
        if( rename_replace_existing( PSA_CS_TEMP, filename ) != 0 )
            status = PSA_ERROR_STORAGE_FAILURE;
    }
    remove( PSA_CS_TEMP );

    return( status );
}

psa_status_t psa_cs_remove( psa_storage_uid_t uid, psa_cs_api_t api )
{
    psa_status_t status = PSA_ERROR_STORAGE_FAILURE;
    char filename[PSA_CS_FILENAME_LENGTH];
    struct psa_storage_info_t info;
    unsigned char sek_buffer[PSA_CS_SEK_LENGTH_IN_BYTES];
    unsigned char *read_file_data = NULL;
    size_t read_file_data_length = 0;

    status = psa_its_fill_filename( uid, filename, api );
    if( status != PSA_SUCCESS )
        goto exit;

    /* Read storage encryption key (SEK). If the key doesn't exists generate a new SEK. */
    status = psa_cs_read_sek(sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, api);
    if( status != PSA_SUCCESS ){
        return status;
    }

    status = psa_its_read_file(uid, sek_buffer, PSA_CS_SEK_LENGTH_IN_BYTES, &info, api, &read_file_data, &read_file_data_length);

    if( status != PSA_SUCCESS )
        goto exit;
    if( info.flags & PSA_STORAGE_FLAG_WRITE_ONCE )
    {
        status = PSA_ERROR_NOT_PERMITTED;
        goto exit;
    }

    if( remove( filename ) != 0 ){
        status = PSA_ERROR_STORAGE_FAILURE;
        goto exit;
    }
    status = PSA_SUCCESS;

exit:
    if( read_file_data != NULL )
        free( read_file_data );
    memset(sek_buffer, 0 , PSA_CS_SEK_LENGTH_IN_BYTES);
    return( status );
}
